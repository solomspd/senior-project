% $ biblatex auxiliary file $
% $ biblatex bbl format version 3.1 $
% Do not modify the above lines!
%
% This is an auxiliary file used by the 'biblatex' package.
% This file may safely be deleted. It will be recreated by
% biber as required.
%
\begingroup
\makeatletter
\@ifundefined{ver@biblatex.sty}
  {\@latex@error
     {Missing 'biblatex' package}
     {The bibliography requires the 'biblatex' package.}
      \aftergroup\endinput}
  {}
\endgroup


\refsection{0}
  \datalist[entry]{none/global//global/global}
    \entry{noauthor_debin_nodate}{online}{}
      \field{sortinit}{1}
      \field{sortinithash}{4f6aaa89bab872aa0999fec09ff8e98a}
      \field{labeltitlesource}{title}
      \field{title}{Debin {|} Proceedings of the 2018 {ACM} {SIGSAC} Conference on Computer and Communications Security}
      \field{urlday}{24}
      \field{urlmonth}{9}
      \field{urlyear}{2021}
      \field{urldateera}{ce}
      \verb{urlraw}
      \verb https://dl.acm.org/doi/10.1145/3243734.3243866
      \endverb
      \verb{url}
      \verb https://dl.acm.org/doi/10.1145/3243734.3243866
      \endverb
    \endentry
    \entry{brumley_bap_2011}{inproceedings}{}
      \name{author}{4}{}{%
        {{hash=cbeda943714c044f03a749cf0a15f952}{%
           family={Brumley},
           familyi={B\bibinitperiod},
           given={David},
           giveni={D\bibinitperiod}}}%
        {{hash=6bd0d5a03def14f6b91557fa135b7941}{%
           family={Jager},
           familyi={J\bibinitperiod},
           given={Ivan},
           giveni={I\bibinitperiod}}}%
        {{hash=35db40352e7e903f8222f5b595ffc4ae}{%
           family={Avgerinos},
           familyi={A\bibinitperiod},
           given={Thanassis},
           giveni={T\bibinitperiod}}}%
        {{hash=306cb39322d65280b134f67c7898e024}{%
           family={Schwartz},
           familyi={S\bibinitperiod},
           given={Edward\bibnamedelima J.},
           giveni={E\bibinitperiod\bibinitdelim J\bibinitperiod}}}%
      }
      \name{editor}{2}{}{%
        {{hash=c4579367a2df427010d033448d6d3748}{%
           family={Gopalakrishnan},
           familyi={G\bibinitperiod},
           given={Ganesh},
           giveni={G\bibinitperiod}}}%
        {{hash=f1b03c9582278ba3b2d670d48bad083d}{%
           family={Qadeer},
           familyi={Q\bibinitperiod},
           given={Shaz},
           giveni={S\bibinitperiod}}}%
      }
      \list{location}{1}{%
        {Berlin, Heidelberg}%
      }
      \list{publisher}{1}{%
        {Springer}%
      }
      \strng{namehash}{7aef89f267b705633b5c05218e15b963}
      \strng{fullhash}{e451b7ce4242979aac55b4751ef6a483}
      \strng{bibnamehash}{e451b7ce4242979aac55b4751ef6a483}
      \strng{authorbibnamehash}{e451b7ce4242979aac55b4751ef6a483}
      \strng{authornamehash}{7aef89f267b705633b5c05218e15b963}
      \strng{authorfullhash}{e451b7ce4242979aac55b4751ef6a483}
      \strng{editorbibnamehash}{ef365c4f42d951adfb13cdebe1253d09}
      \strng{editornamehash}{ef365c4f42d951adfb13cdebe1253d09}
      \strng{editorfullhash}{ef365c4f42d951adfb13cdebe1253d09}
      \field{sortinit}{2}
      \field{sortinithash}{8b555b3791beccb63322c22f3320aa9a}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{shorttitle}
      \field{abstract}{{BAP} is a publicly available infrastructure for performing program verification and analysis tasks on binary (i.e., executable) code. In this paper, we describe {BAP} as well as lessons learned from previous incarnations of binary analysis platforms. {BAP} explicitly represents all side effects of instructions in an intermediate language ({IL}), making syntaxdirected analysis possible. We have used {BAP} to routinely generate and solve verification conditions that are hundreds of megabytes in size and encompass 100,000’s of assembly instructions.}
      \field{booktitle}{Computer Aided Verification}
      \field{isbn}{978-3-642-22110-1}
      \field{langid}{english}
      \field{series}{Lecture Notes in Computer Science}
      \field{shorttitle}{{BAP}}
      \field{title}{{BAP}: A Binary Analysis Platform}
      \field{year}{2011}
      \field{dateera}{ce}
      \field{pages}{463\bibrangedash 469}
      \range{pages}{7}
      \verb{doi}
      \verb 10.1007/978-3-642-22110-1_37
      \endverb
      \keyw{Binary Analysis,Binary Code,Intermediate Language,Strongly Connect Component,Symbolic Execution}
    \endentry
    \entry{miller_probabilistic_2019}{inproceedings}{}
      \name{author}{6}{}{%
        {{hash=50d400e036ffe00d68ef6ac4f7949053}{%
           family={Miller},
           familyi={M\bibinitperiod},
           given={Kenneth},
           giveni={K\bibinitperiod}}}%
        {{hash=210a3f7c7ca2912bcd23f0d359646f83}{%
           family={Kwon},
           familyi={K\bibinitperiod},
           given={Yonghwi},
           giveni={Y\bibinitperiod}}}%
        {{hash=4ecf6f19fcc21ef32abbea3a7f2a885c}{%
           family={Sun},
           familyi={S\bibinitperiod},
           given={Yi},
           giveni={Y\bibinitperiod}}}%
        {{hash=884df7ab45641d489531d7b9dba66003}{%
           family={Zhang},
           familyi={Z\bibinitperiod},
           given={Zhuo},
           giveni={Z\bibinitperiod}}}%
        {{hash=5e72bc22dbcf0984c6d113d280e36990}{%
           family={Zhang},
           familyi={Z\bibinitperiod},
           given={Xiangyu},
           giveni={X\bibinitperiod}}}%
        {{hash=3a0fad1a4b2365ac32b3fc6cb8579eb2}{%
           family={Lin},
           familyi={L\bibinitperiod},
           given={Zhiqiang},
           giveni={Z\bibinitperiod}}}%
      }
      \strng{namehash}{fd5dab037b89991f8d794a3f207401b1}
      \strng{fullhash}{894f27d641438e08aecfe20822e22c0e}
      \strng{bibnamehash}{894f27d641438e08aecfe20822e22c0e}
      \strng{authorbibnamehash}{894f27d641438e08aecfe20822e22c0e}
      \strng{authornamehash}{fd5dab037b89991f8d794a3f207401b1}
      \strng{authorfullhash}{894f27d641438e08aecfe20822e22c0e}
      \field{sortinit}{3}
      \field{sortinithash}{ad6fe7482ffbd7b9f99c9e8b5dccd3d7}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{Disassembling stripped binaries is a prominent challenge for binary analysis, due to the interleaving of code segments and data, and the difficulties of resolving control transfer targets of indirect calls and jumps. As a result, most existing disassemblers have both false positives ({FP}) and false negatives ({FN}). We observe that uncertainty is inevitable in disassembly due to the information loss during compilation and code generation. Therefore, we propose to model such uncertainty using probabilities and propose a novel disassembly technique, which computes a probability for each address in the code space, indicating its likelihood of being a true positive instruction. The probability is computed from a set of features that are reachable to an address, including control flow and data flow features. Our experiments with more than two thousands binaries show that our technique does not have any {FN} and has only 3.7\% {FP}. In comparison, a state-of-the-art superset disassembly technique has 85\% {FP}. A rewriter built on our disassembly can generate binaries that are only half of the size of those by superset disassembly and run 3\% faster. While many widely-used disassemblers such as {IDA} and {BAP} suffer from missing function entries, our experiment also shows that even without any function entry information, our disassembler can still achieve 0 {FN} and 6.8\% {FP}.}
      \field{booktitle}{2019 {IEEE}/{ACM} 41st International Conference on Software Engineering ({ICSE})}
      \field{eventtitle}{2019 {IEEE}/{ACM} 41st International Conference on Software Engineering ({ICSE})}
      \field{month}{5}
      \field{note}{{ISSN}: 1558-1225}
      \field{title}{Probabilistic Disassembly}
      \field{year}{2019}
      \field{dateera}{ce}
      \field{pages}{1187\bibrangedash 1198}
      \range{pages}{12}
      \verb{doi}
      \verb 10.1109/ICSE.2019.00121
      \endverb
      \keyw{Computer science,Aggregates,binary,binary rewrite,disassembly,Instruments,probabilistic disassembly,Probabilistic logic,Registers,Runtime,Uncertainty}
    \endentry
    \entry{harrand_java_2020}{article}{}
      \name{author}{4}{}{%
        {{hash=dbb5a37bd08678f32cf8540d4ed77f4b}{%
           family={Harrand},
           familyi={H\bibinitperiod},
           given={Nicolas},
           giveni={N\bibinitperiod}}}%
        {{hash=34b886fd4a4addc25d0a70e9aa34c8ea}{%
           family={Soto-Valero},
           familyi={S\bibinithyphendelim V\bibinitperiod},
           given={César},
           giveni={C\bibinitperiod}}}%
        {{hash=98f471912e248a73379dde4aa46e4ecf}{%
           family={Monperrus},
           familyi={M\bibinitperiod},
           given={Martin},
           giveni={M\bibinitperiod}}}%
        {{hash=5bccc8108bd2ef1b1e2cfc63031932f0}{%
           family={Baudry},
           familyi={B\bibinitperiod},
           given={Benoit},
           giveni={B\bibinitperiod}}}%
      }
      \strng{namehash}{d71466353057d7ae02d3fcecd1ab2ed0}
      \strng{fullhash}{2e44299b10333b1352081fb5821fda07}
      \strng{bibnamehash}{2e44299b10333b1352081fb5821fda07}
      \strng{authorbibnamehash}{2e44299b10333b1352081fb5821fda07}
      \strng{authornamehash}{d71466353057d7ae02d3fcecd1ab2ed0}
      \strng{authorfullhash}{2e44299b10333b1352081fb5821fda07}
      \field{sortinit}{4}
      \field{sortinithash}{9381316451d1b9788675a07e972a12a7}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{During compilation from Java source code to bytecode, some information is irreversibly lost. In other words, compilation and decompilation of Java code is not symmetric. Consequently, decompilation, which aims at producing source code from bytecode, relies on strategies to reconstruct the information that has been lost. Different Java decompilers use distinct strategies to achieve proper decompilation. In this work, we hypothesize that the diverse ways in which bytecode can be decompiled has a direct impact on the quality of the source code produced by decompilers. In this paper, we assess the strategies of eight Java decompilers with respect to three quality indicators: syntactic correctness, syntactic distortion and semantic equivalence modulo inputs. Our results show that no single modern decompiler is able to correctly handle the variety of bytecode structures coming from real-world programs. The highest ranking decompiler in this study produces syntactically correct, and semantically equivalent code output for 84\%, respectively 78\%, of the classes in our dataset. Our results demonstrate that each decompiler correctly handles a different set of bytecode classes. We propose a new decompiler called Arlecchino that leverages the diversity of existing decompilers. To do so, we merge partial decompilation into a new one based on compilation errors. Arlecchino handles 37.6\% of bytecode classes that were previously handled by no decompiler. We publish the sources of this new bytecode decompiler.}
      \field{day}{1}
      \field{issn}{0164-1212}
      \field{journaltitle}{Journal of Systems and Software}
      \field{langid}{english}
      \field{month}{10}
      \field{shortjournal}{Journal of Systems and Software}
      \field{title}{Java decompiler diversity and its application to meta-decompilation}
      \field{urlday}{24}
      \field{urlmonth}{9}
      \field{urlyear}{2021}
      \field{volume}{168}
      \field{year}{2020}
      \field{dateera}{ce}
      \field{urldateera}{ce}
      \field{pages}{110645}
      \range{pages}{1}
      \verb{doi}
      \verb 10.1016/j.jss.2020.110645
      \endverb
      \verb{urlraw}
      \verb https://www.sciencedirect.com/science/article/pii/S0164121220301151
      \endverb
      \verb{url}
      \verb https://www.sciencedirect.com/science/article/pii/S0164121220301151
      \endverb
      \keyw{Decompilation,Java bytecode,Reverse engineering,Source code analysis}
    \endentry
    \entry{jang_kerberoid_2019}{inproceedings}{}
      \name{author}{4}{}{%
        {{hash=02134885bbd677303c17ca65c370dc1d}{%
           family={Jang},
           familyi={J\bibinitperiod},
           given={Heejun},
           giveni={H\bibinitperiod}}}%
        {{hash=d902391a700eed83b7b0904c953e8122}{%
           family={Jin},
           familyi={J\bibinitperiod},
           given={Beomjin},
           giveni={B\bibinitperiod}}}%
        {{hash=a60d8246cc8a01d5fa770a39bbf92164}{%
           family={Hyun},
           familyi={H\bibinitperiod},
           given={Sangwon},
           giveni={S\bibinitperiod}}}%
        {{hash=3587bd1be4ca32215645ec1603bccf89}{%
           family={Kim},
           familyi={K\bibinitperiod},
           given={Hyoungshick},
           giveni={H\bibinitperiod}}}%
      }
      \list{location}{1}{%
        {New York, {NY}, {USA}}%
      }
      \list{publisher}{1}{%
        {Association for Computing Machinery}%
      }
      \strng{namehash}{cb6fca2cd2174ebbe85be60422f8ccfd}
      \strng{fullhash}{65a252188b19ee4e548c54a550c28bd9}
      \strng{bibnamehash}{65a252188b19ee4e548c54a550c28bd9}
      \strng{authorbibnamehash}{65a252188b19ee4e548c54a550c28bd9}
      \strng{authornamehash}{cb6fca2cd2174ebbe85be60422f8ccfd}
      \strng{authorfullhash}{65a252188b19ee4e548c54a550c28bd9}
      \field{sortinit}{1}
      \field{sortinithash}{4f6aaa89bab872aa0999fec09ff8e98a}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{shorttitle}
      \field{abstract}{Decompilation is frequently used to analyze binary programs. In Android, however, decompilers all perform differently with varying apps due to their own characteristics. Obviously, there is no universal solution in all conditions. Based on this observation, we present a practical Android app decompilation system (called Kerberoid) that automatically stitches the results from multiple decompilers together to maximize the coverage and the accuracy of decompiled codes. We evaluate the performance of Kerberoid with 151 Android apps in which their corresponding source codes are publicly available. Kerberoid fully recovered all functions for 17\% of the apps tested and gained a similarity score over 50\% for 40\% of the apps tested, increased by 7\% and 9\%, respectively, compared with the best existing decompiler.}
      \field{booktitle}{Proceedings of the 2019 {ACM} {SIGSAC} Conference on Computer and Communications Security}
      \field{day}{6}
      \field{isbn}{978-1-4503-6747-9}
      \field{month}{11}
      \field{series}{{CCS} '19}
      \field{shorttitle}{Kerberoid}
      \field{title}{Kerberoid: A Practical Android App Decompilation System with Multiple Decompilers}
      \field{urlday}{24}
      \field{urlmonth}{9}
      \field{urlyear}{2021}
      \field{year}{2019}
      \field{dateera}{ce}
      \field{urldateera}{ce}
      \field{pages}{2557\bibrangedash 2559}
      \range{pages}{3}
      \verb{doi}
      \verb 10.1145/3319535.3363255
      \endverb
      \verb{urlraw}
      \verb https://doi.org/10.1145/3319535.3363255
      \endverb
      \verb{url}
      \verb https://doi.org/10.1145/3319535.3363255
      \endverb
      \keyw{android apps,decompilation,mobile security,reverse engineering}
    \endentry
    \entry{naitian_dexfus_2020}{inproceedings}{}
      \name{author}{5}{}{%
        {{hash=543ea5a616a21bdb963b8c0dda662392}{%
           family={Naitian},
           familyi={N\bibinitperiod},
           given={Hu},
           giveni={H\bibinitperiod}}}%
        {{hash=7fe906a173065b6cd23ee6bb227ce561}{%
           family={Xingkong},
           familyi={X\bibinitperiod},
           given={Ma},
           giveni={M\bibinitperiod}}}%
        {{hash=360d959def8ba9fe751f21a679e9c973}{%
           family={Lin},
           familyi={L\bibinitperiod},
           given={Fuqiang},
           giveni={F\bibinitperiod}}}%
        {{hash=c97e20777166561cf99ddc1272bea36a}{%
           family={Bo},
           familyi={B\bibinitperiod},
           given={Liu},
           giveni={L\bibinitperiod}}}%
        {{hash=8851dff5036eb383299185ed7b008d21}{%
           family={Tong},
           familyi={T\bibinitperiod},
           given={Lu},
           giveni={L\bibinitperiod}}}%
      }
      \strng{namehash}{9d84bbfa935cec1483dd66b447449075}
      \strng{fullhash}{6408590126eb85bc88141cf29c9a240a}
      \strng{bibnamehash}{6408590126eb85bc88141cf29c9a240a}
      \strng{authorbibnamehash}{6408590126eb85bc88141cf29c9a240a}
      \strng{authornamehash}{9d84bbfa935cec1483dd66b447449075}
      \strng{authorfullhash}{6408590126eb85bc88141cf29c9a240a}
      \field{sortinit}{1}
      \field{sortinithash}{4f6aaa89bab872aa0999fec09ff8e98a}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{shorttitle}
      \field{abstract}{{DexFus} applies obfuscation on translated C code instead of the original Dalvik code, which provides a higher level protection for applications, and is able to protect target applications with reasonable storage and memory overhead and high stability. Cracking and repackaging is a severe threat to Android applications. Obfuscation increases the difficulty of reverse analysis without changing the semantics of the original code. However, current Android obfuscation techniques primarily concentrate on Dalvik bytecode obfuscation, as Dalvik bytecode contains much semantic information, obfuscation does not hinder the attacker much. We propose a new technique named {DexFus} for protecting Android code based on Dalvik bytecode translation. {DexFus} applies obfuscation on translated C code instead of the original Dalvik code, which provides a higher level protection for applications. A prototype deployment on the Android platform demonstrates that {DexFus} is able to protect target applications with reasonable storage and memory overhead and high stability.}
      \field{shorttitle}{{DexFus}}
      \field{title}{{DexFus}: An Android Obfuscation Technique Based on Dalvik Bytecode Translation}
      \field{year}{2020}
      \field{dateera}{ce}
      \verb{doi}
      \verb 10.1007/978-981-15-9739-8_32
      \endverb
    \endentry
    \entry{katz_using_2018}{inproceedings}{}
      \name{author}{3}{}{%
        {{hash=5fd7786e7288f3da75cdc0bb4159a297}{%
           family={Katz},
           familyi={K\bibinitperiod},
           given={Deborah\bibnamedelima S.},
           giveni={D\bibinitperiod\bibinitdelim S\bibinitperiod}}}%
        {{hash=f233b6c75acb8c68b1eea06bfec33ab8}{%
           family={Ruchti},
           familyi={R\bibinitperiod},
           given={Jason},
           giveni={J\bibinitperiod}}}%
        {{hash=f07f98d404162233a180cc22241d9afc}{%
           family={Schulte},
           familyi={S\bibinitperiod},
           given={Eric},
           giveni={E\bibinitperiod}}}%
      }
      \strng{namehash}{6545b4a4c45bdd28744c7c5f89091c58}
      \strng{fullhash}{6545b4a4c45bdd28744c7c5f89091c58}
      \strng{bibnamehash}{6545b4a4c45bdd28744c7c5f89091c58}
      \strng{authorbibnamehash}{6545b4a4c45bdd28744c7c5f89091c58}
      \strng{authornamehash}{6545b4a4c45bdd28744c7c5f89091c58}
      \strng{authorfullhash}{6545b4a4c45bdd28744c7c5f89091c58}
      \field{sortinit}{1}
      \field{sortinithash}{4f6aaa89bab872aa0999fec09ff8e98a}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{Decompilation, recovering source code from binary, is useful in many situations where it is necessary to analyze or understand software for which source code is not available. Source code is much easier for humans to read than binary code, and there are many tools available to analyze source code. Existing decompilation techniques often generate source code that is difficult for humans to understand because the generated code often does not use the coding idioms that programmers use. Differences from human-written code also reduce the effectiveness of analysis tools on the decompiled source code. To address the problem of differences between decompiled code and human-written code, we present a novel technique for decompiling binary code snippets using a model based on Recurrent Neural Networks. The model learns properties and patterns that occur in source code and uses them to produce decompilation output. We train and evaluate our technique on snippets of binary machine code compiled from C source code. The general approach we outline in this paper is not language-specific and requires little or no domain knowledge of a language and its properties or how a compiler operates, making the approach easily extensible to new languages and constructs. Furthermore, the technique can be extended and applied in situations to which traditional decompilers are not targeted, such as for decompilation of isolated binary snippets; fast, on-demand decompilation; domain-specific learned decompilation; optimizing for readability of decompilation; and recovering control flow constructs, comments, and variable or function names. We show that the translations produced by this technique are often accurate or close and can provide a useful picture of the snippet's behavior.}
      \field{booktitle}{2018 {IEEE} 25th International Conference on Software Analysis, Evolution and Reengineering ({SANER})}
      \field{eventtitle}{2018 {IEEE} 25th International Conference on Software Analysis, Evolution and Reengineering ({SANER})}
      \field{month}{3}
      \field{title}{Using recurrent neural networks for decompilation}
      \field{year}{2018}
      \field{dateera}{ce}
      \field{pages}{346\bibrangedash 356}
      \range{pages}{11}
      \verb{doi}
      \verb 10.1109/SANER.2018.8330222
      \endverb
      \keyw{decompilation,Binary codes,Data models,Decoding,deep learning,Natural languages,recurrent neural networks,Recurrent neural networks,Tools,Training,translation}
    \endentry
    \entry{fu_neural-based_2019}{article}{}
      \name{author}{7}{}{%
        {{hash=4636eee81d8b7a30715d001690daae10}{%
           family={Fu},
           familyi={F\bibinitperiod},
           given={Cheng},
           giveni={C\bibinitperiod}}}%
        {{hash=f2d7ca7dd4b13c195e5770539ee36649}{%
           family={Chen},
           familyi={C\bibinitperiod},
           given={Huili},
           giveni={H\bibinitperiod}}}%
        {{hash=1c471f914e730b1ded187e9ffbc60acf}{%
           family={Liu},
           familyi={L\bibinitperiod},
           given={Haolan},
           giveni={H\bibinitperiod}}}%
        {{hash=2f993628f01d1c59a05a60f5687d3c03}{%
           family={Chen},
           familyi={C\bibinitperiod},
           given={Xinyun},
           giveni={X\bibinitperiod}}}%
        {{hash=074caf23cc82a3b80220324f240e9327}{%
           family={Tian},
           familyi={T\bibinitperiod},
           given={Yuandong},
           giveni={Y\bibinitperiod}}}%
        {{hash=d1642679ae78814302ce585a8ca745a8}{%
           family={Koushanfar},
           familyi={K\bibinitperiod},
           given={Farinaz},
           giveni={F\bibinitperiod}}}%
        {{hash=7bc49f2d8d952a3d6daf7b5435ecc739}{%
           family={Zhao},
           familyi={Z\bibinitperiod},
           given={Jishen},
           giveni={J\bibinitperiod}}}%
      }
      \strng{namehash}{d5fd155ee2e6bf2c41bf9c8013b1de2f}
      \strng{fullhash}{c19e98322a16bcc1d893057c18ce9ae4}
      \strng{bibnamehash}{c19e98322a16bcc1d893057c18ce9ae4}
      \strng{authorbibnamehash}{c19e98322a16bcc1d893057c18ce9ae4}
      \strng{authornamehash}{d5fd155ee2e6bf2c41bf9c8013b1de2f}
      \strng{authorfullhash}{c19e98322a16bcc1d893057c18ce9ae4}
      \field{sortinit}{2}
      \field{sortinithash}{8b555b3791beccb63322c22f3320aa9a}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{Reverse engineering of binary executables is a critical problem in the computer security domain. On the one hand, malicious parties may recover interpretable source codes from the software products to gain commercial advantages. On the other hand, binary decompilation can be leveraged for code vulnerability analysis and malware detection. However, efficient binary decompilation is challenging. Conventional decompilers have the following major limitations: (i) they are only applicable to specific source-target language pair, hence incurs undesired development cost for new language tasks; (ii) their output high-level code cannot effectively preserve the correct functionality of the input binary; (iii) their output program does not capture the semantics of the input and the reversed program is hard to interpret. To address the above problems, we propose Coda, the first end-to-end neural-based framework for code decompilation. Coda decomposes the decompilation task into two key phases: First, Coda employs an instruction type-aware encoder and a tree decoder for generating an abstract syntax tree ({AST}) with attention feeding during the code sketch generation stage. Second, Coda then updates the code sketch using an iterative error correction machine guided by an ensembled neural error predictor. By finding a good approximate candidate and then fixing it towards perfect, Coda achieves superior performance compared to baseline approaches. We assess Coda's performance with extensive experiments on various benchmarks. Evaluation results show that Coda achieves an average of 82{\textbackslash}\% program recovery accuracy on unseen binary samples, where the state-of-the-art decompilers yield 0{\textbackslash}\% accuracy. Furthermore, Coda outperforms the sequence-to-sequence model with attention by a margin of 70{\textbackslash}\% program accuracy.}
      \field{day}{27}
      \field{eprinttype}{arxiv}
      \field{journaltitle}{{arXiv}:1906.12029 [cs]}
      \field{month}{6}
      \field{title}{A Neural-based Program Decompiler}
      \field{urlday}{28}
      \field{urlmonth}{9}
      \field{urlyear}{2021}
      \field{year}{2019}
      \field{dateera}{ce}
      \field{urldateera}{ce}
      \verb{eprint}
      \verb 1906.12029
      \endverb
      \verb{urlraw}
      \verb http://arxiv.org/abs/1906.12029
      \endverb
      \verb{url}
      \verb http://arxiv.org/abs/1906.12029
      \endverb
      \keyw{Computer Science - Machine Learning,Computer Science - Programming Languages}
    \endentry
    \entry{katz_towards_2019}{article}{}
      \name{author}{4}{}{%
        {{hash=a7db0c3fdc60e68f9c8aba4bc6370be8}{%
           family={Katz},
           familyi={K\bibinitperiod},
           given={Omer},
           giveni={O\bibinitperiod}}}%
        {{hash=4ebb260bb109b1d587d4486adb67e06a}{%
           family={Olshaker},
           familyi={O\bibinitperiod},
           given={Yuval},
           giveni={Y\bibinitperiod}}}%
        {{hash=33b00f3e2f4f1bb310f1cf8d4a4c500a}{%
           family={Goldberg},
           familyi={G\bibinitperiod},
           given={Yoav},
           giveni={Y\bibinitperiod}}}%
        {{hash=1336db0a6cad45c95c6bc395c65379e3}{%
           family={Yahav},
           familyi={Y\bibinitperiod},
           given={Eran},
           giveni={E\bibinitperiod}}}%
      }
      \strng{namehash}{01dec19c2eba5a50936ae2d9c556d3b0}
      \strng{fullhash}{5d04c25886683df90964a28c7e5de014}
      \strng{bibnamehash}{5d04c25886683df90964a28c7e5de014}
      \strng{authorbibnamehash}{5d04c25886683df90964a28c7e5de014}
      \strng{authornamehash}{01dec19c2eba5a50936ae2d9c556d3b0}
      \strng{authorfullhash}{5d04c25886683df90964a28c7e5de014}
      \field{sortinit}{3}
      \field{sortinithash}{ad6fe7482ffbd7b9f99c9e8b5dccd3d7}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{We address the problem of automatic decompilation, converting a program in low-level representation back to a higher-level human-readable programming language. The problem of decompilation is extremely important for security researchers. Finding vulnerabilities and understanding how malware operates is much easier when done over source code. The importance of decompilation has motivated the construction of hand-crafted rule-based decompilers. Such decompilers have been designed by experts to detect specific control-flow structures and idioms in low-level code and lift them to source level. The cost of supporting additional languages or new language features in these models is very high. We present a novel approach to decompilation based on neural machine translation. The main idea is to automatically learn a decompiler from a given compiler. Given a compiler from a source language S to a target language T , our approach automatically trains a decompiler that can translate (decompile) T back to S . We used our framework to decompile both {LLVM} {IR} and x86 assembly to C code with high success rates. Using our {LLVM} and x86 instantiations, we were able to successfully decompile over 97\% and 88\% of our benchmarks respectively.}
      \field{day}{20}
      \field{eprinttype}{arxiv}
      \field{journaltitle}{{arXiv}:1905.08325 [cs]}
      \field{month}{5}
      \field{title}{Towards Neural Decompilation}
      \field{urlday}{28}
      \field{urlmonth}{9}
      \field{urlyear}{2021}
      \field{year}{2019}
      \field{dateera}{ce}
      \field{urldateera}{ce}
      \verb{eprint}
      \verb 1905.08325
      \endverb
      \verb{urlraw}
      \verb http://arxiv.org/abs/1905.08325
      \endverb
      \verb{url}
      \verb http://arxiv.org/abs/1905.08325
      \endverb
      \keyw{Computer Science - Machine Learning,Computer Science - Programming Languages}
    \endentry
    \entry{fu_n-bref_2020}{article}{}
      \name{author}{5}{}{%
        {{hash=4636eee81d8b7a30715d001690daae10}{%
           family={Fu},
           familyi={F\bibinitperiod},
           given={Cheng},
           giveni={C\bibinitperiod}}}%
        {{hash=2eb6805196602554ade750f9c861a38f}{%
           family={Yang},
           familyi={Y\bibinitperiod},
           given={Kunlin},
           giveni={K\bibinitperiod}}}%
        {{hash=2f993628f01d1c59a05a60f5687d3c03}{%
           family={Chen},
           familyi={C\bibinitperiod},
           given={Xinyun},
           giveni={X\bibinitperiod}}}%
        {{hash=074caf23cc82a3b80220324f240e9327}{%
           family={Tian},
           familyi={T\bibinitperiod},
           given={Yuandong},
           giveni={Y\bibinitperiod}}}%
        {{hash=7bc49f2d8d952a3d6daf7b5435ecc739}{%
           family={Zhao},
           familyi={Z\bibinitperiod},
           given={Jishen},
           giveni={J\bibinitperiod}}}%
      }
      \strng{namehash}{2469b77a135ff8ea074d5c7704658328}
      \strng{fullhash}{ae00fe4226f9dc7b5cf6c91a8fda2927}
      \strng{bibnamehash}{ae00fe4226f9dc7b5cf6c91a8fda2927}
      \strng{authorbibnamehash}{ae00fe4226f9dc7b5cf6c91a8fda2927}
      \strng{authornamehash}{2469b77a135ff8ea074d5c7704658328}
      \strng{authorfullhash}{ae00fe4226f9dc7b5cf6c91a8fda2927}
      \field{sortinit}{4}
      \field{sortinithash}{9381316451d1b9788675a07e972a12a7}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{shorttitle}
      \field{abstract}{Binary decompilation is a powerful technique for analyzing and understanding software, when source code is unavailable. It is a critical problem in the computer security domain. With the success of...}
      \field{day}{28}
      \field{langid}{english}
      \field{month}{9}
      \field{shorttitle}{N-Bref}
      \field{title}{N-Bref : A High-fidelity Decompiler Exploiting Programming Structures}
      \field{urlday}{24}
      \field{urlmonth}{9}
      \field{urlyear}{2021}
      \field{year}{2020}
      \field{dateera}{ce}
      \field{urldateera}{ce}
      \verb{urlraw}
      \verb https://openreview.net/forum?id=6GkL6qM3LV
      \endverb
      \verb{url}
      \verb https://openreview.net/forum?id=6GkL6qM3LV
      \endverb
    \endentry
    \entry{liang_neutron_2021}{article}{}
      \name{author}{4}{}{%
        {{hash=dbc68548306f3e04eb9a66fbf7ccd291}{%
           family={Liang},
           familyi={L\bibinitperiod},
           given={Ruigang},
           giveni={R\bibinitperiod}}}%
        {{hash=e2faa61ea3eaaac7d1b412e64f8f6e0b}{%
           family={Cao},
           familyi={C\bibinitperiod},
           given={Ying},
           giveni={Y\bibinitperiod}}}%
        {{hash=c084db58407b7a953805cff730be2a1c}{%
           family={Hu},
           familyi={H\bibinitperiod},
           given={Peiwei},
           giveni={P\bibinitperiod}}}%
        {{hash=ee3f7d7b96add98106db907e189d6c13}{%
           family={Chen},
           familyi={C\bibinitperiod},
           given={Kai},
           giveni={K\bibinitperiod}}}%
      }
      \strng{namehash}{f27acdaa58dc409f8436868fbf35f02c}
      \strng{fullhash}{3ed2844eac943c3366d7054fa4188427}
      \strng{bibnamehash}{3ed2844eac943c3366d7054fa4188427}
      \strng{authorbibnamehash}{3ed2844eac943c3366d7054fa4188427}
      \strng{authornamehash}{f27acdaa58dc409f8436868fbf35f02c}
      \strng{authorfullhash}{3ed2844eac943c3366d7054fa4188427}
      \field{sortinit}{4}
      \field{sortinithash}{9381316451d1b9788675a07e972a12a7}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{shorttitle}
      \field{abstract}{Decompilation aims to analyze and transform low-level program language ({PL}) codes such as binary code or assembly code to obtain an equivalent high-level {PL}. Decompilation plays a vital role in the cyberspace security fields such as software vulnerability discovery and analysis, malicious code detection and analysis, and software engineering fields such as source code analysis, optimization, and cross-language cross-operating system migration. Unfortunately, the existing decompilers mainly rely on experts to write rules, which leads to bottlenecks such as low scalability, development difficulties, and long cycles. The generated high-level {PL} codes often violate the code writing specifications. Further, their readability is still relatively low. The problems mentioned above hinder the efficiency of advanced applications (e.g., vulnerability discovery) based on decompiled high-level {PL} codes.In this paper, we propose a decompilation approach based on the attention-based neural machine translation ({NMT}) mechanism, which converts low-level {PL} into high-level {PL} while acquiring legibility and keeping functionally similar. To compensate for the information asymmetry between the low-level and high-level {PL}, a translation method based on basic operations of low-level {PL} is designed. This method improves the generalization of the {NMT} model and captures the translation rules between {PLs} more accurately and efficiently. Besides, we implement a neural decompilation framework called Neutron. The evaluation of two practical applications shows that Neutron’s average program accuracy is 96.96\%, which is better than the traditional {NMT} model.}
      \field{day}{5}
      \field{issn}{2523-3246}
      \field{journaltitle}{Cybersecurity}
      \field{langid}{english}
      \field{month}{3}
      \field{number}{1}
      \field{shortjournal}{Cybersecur}
      \field{shorttitle}{Neutron}
      \field{title}{Neutron: an attention-based neural decompiler}
      \field{urlday}{28}
      \field{urlmonth}{9}
      \field{urlyear}{2021}
      \field{volume}{4}
      \field{year}{2021}
      \field{dateera}{ce}
      \field{urldateera}{ce}
      \field{pages}{5}
      \range{pages}{1}
      \verb{doi}
      \verb 10.1186/s42400-021-00070-0
      \endverb
      \verb{urlraw}
      \verb https://doi.org/10.1186/s42400-021-00070-0
      \endverb
      \verb{url}
      \verb https://doi.org/10.1186/s42400-021-00070-0
      \endverb
    \endentry
    \entry{schulte_evolving_2018}{inproceedings}{}
      \name{author}{5}{}{%
        {{hash=f07f98d404162233a180cc22241d9afc}{%
           family={Schulte},
           familyi={S\bibinitperiod},
           given={Eric},
           giveni={E\bibinitperiod}}}%
        {{hash=f233b6c75acb8c68b1eea06bfec33ab8}{%
           family={Ruchti},
           familyi={R\bibinitperiod},
           given={Jason},
           giveni={J\bibinitperiod}}}%
        {{hash=8598d5481ce7573a31baebdfdd127134}{%
           family={Noonan},
           familyi={N\bibinitperiod},
           given={Matt},
           giveni={M\bibinitperiod}}}%
        {{hash=b8b4df27cab53027402d393bfddbf622}{%
           family={Ciarletta},
           familyi={C\bibinitperiod},
           given={David},
           giveni={D\bibinitperiod}}}%
        {{hash=22d6f87b3afc1795e8d7518643f826ab}{%
           family={Loginov},
           familyi={L\bibinitperiod},
           given={Alexey},
           giveni={A\bibinitperiod}}}%
      }
      \strng{namehash}{5ec9bd2ae9166d0e95dcc071264361e0}
      \strng{fullhash}{e6683f7b229266188ab09011b03da376}
      \strng{bibnamehash}{e6683f7b229266188ab09011b03da376}
      \strng{authorbibnamehash}{e6683f7b229266188ab09011b03da376}
      \strng{authornamehash}{5ec9bd2ae9166d0e95dcc071264361e0}
      \strng{authorfullhash}{e6683f7b229266188ab09011b03da376}
      \field{sortinit}{4}
      \field{sortinithash}{9381316451d1b9788675a07e972a12a7}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{day}{1}
      \field{month}{1}
      \field{title}{Evolving Exact Decompilation}
      \field{year}{2018}
      \field{dateera}{ce}
      \verb{doi}
      \verb 10.14722/bar.2018.23008
      \endverb
    \endentry
  \enddatalist
\endrefsection
\endinput

